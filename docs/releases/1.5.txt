============================================
Django 1.5 release notes - UNDER DEVELOPMENT
============================================

This page documents release notes for the as-yet-unreleased Django
1.5. As such, it's tentative and subject to change. It provides
up-to-date information for those who are following trunk.

Django 1.5 includes various `new features`_ and some minor `backwards
incompatible changes`_. There are also some features that have been dropped,
which are detailed in :doc:`our deprecation plan </internals/deprecation>`, and
we've `begun the deprecation process for some features`_.


.. _new features: `What's new in Django 1.5`_
.. _backwards incompatible changes: backwards-incompatible-changes-1.5_
.. _begun the deprecation process for some features: deprecated-features-1.5_

What's new in Django 1.5
========================

Private widgets API
~~~~~~~~~~~~~~~~~~~

With the addition of a template-based widgets API, parts of the
widgets API have been deprecated. They weren't considered as public parts and
if you use standard widgets, backwards compatibility applies. However, if you
have custom widgets defined using the mechanisms above, you will need to
update them to the new API:

* ``MultiWidget``'s ``format_output`` method has been deprecated. Existing
  implementations of ``format_output`` to add data between widgets won't have
  any effect.

* ``RadioSelect``'s ``renderer`` API has been deprecated. Direct call to
  ``RadioSelect``'s ``get_renderer()`` method still works but assiging a
  custom renderer to ``RadioSelect`` won't have any impact on the rendering.

Widgets API
~~~~~~~~~~~

The form widgets now have a :doc:`public API<../ref/forms/widgets>` for easier
custom rendering: the rendering is now done using Django templates and hooks
have been added to let users define custom widgets. An additional template
loader (``django.template.loaders.forms.Loader``) that loads widget templates
is enabled by default and will be until Django 1.6.

HTML comparisons in tests
~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`~django.test.testcase.TestCase` base class provided by django has
now some helpers to compare HTML on it's semantical equivilance. Basic
differences like argument quoting and how self-closing tags are closed are
ignored. HTML can either be compared directly with the new
:meth:`~django.test.testcase.TestCase.assertHTMLEqual` and
:meth:`~django.test.testcase.TestCase.assertHTMLNotEqual` assertions or use
the ``html=True`` flag with
:meth:`~django.test.testcase.TestCase.assertContains` and :meth:`~django.test.testcase.TestCase.assertNotContains` to test if the test
client's response contains a HTML fragment. See the :ref:`assertion
documentation<assertions>` for more information.

``assertTemplateUsed`` as context managers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is now possible to check whether a template was used or not in a block of
code with the :meth:`~django.test.testcase.TestCase.assertTemplateUsed` and
:meth:`~django.test.testcase.TestCase.assertTemplateNotUsed` assertions. They
can be used as a context manager::

    with self.assertTemplateUsed('index.html'):
        render_to_string('index.html')
    with self.assertTemplateNotUsed('base.html'):
        render_to_string('index.html')

See the :ref:`assertion documentation<assertions>` for more information.

.. _backwards-incompatible-changes-1.5:
.. _deprecated-features-1.5:
