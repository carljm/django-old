==================
Working with forms
==================

.. admonition:: About this document

    This document provides an introduction to Django's form handling features.
    For a more detailed look at specific areas of the forms API, see
    :doc:`/ref/forms/api`, :doc:`/ref/forms/fields`, and
    :doc:`/ref/forms/validation`.

.. highlightlang:: html+django

``django.forms`` is Django's form-handling library.

While it is possible to process form submissions just using Django's
:class:`~django.http.HttpRequest` class, using the form library takes care of a
number of common form-related tasks. Using it, you can:

    1. Display an HTML form with automatically generated form widgets.
    2. Check submitted data against a set of validation rules.
    3. Redisplay a form in the case of validation errors.
    4. Convert submitted form data to the relevant Python data types.

Overview
========

The library deals with these concepts:

.. glossary::

    Widget
        A class that corresponds to an HTML form widget, e.g.
        ``<input type="text">`` or ``<textarea>``. This handles rendering of the
        widget as HTML.

    Field
        A class that is responsible for doing validation, e.g.
        an ``EmailField`` that makes sure its data is a valid email address.

    Form
        A collection of fields that knows how to validate itself.

    Form Media
        The CSS and JavaScript resources that are required to render a form.

The library is decoupled from the other Django components, such as the database
layer, views and templates. It relies only on Django settings, a couple of
``django.utils`` helper functions and Django's internationalization hooks (but
you're not required to be using internationalization features to use this
library).

Form objects
============

A Form object encapsulates a sequence of form fields and a collection of
validation rules that must be fulfilled in order for the form to be accepted.
Form classes are created as subclasses of ``django.forms.Form`` and
make use of a declarative style that you'll be familiar with if you've used
Django's database models.

For example, consider a form used to implement "contact me" functionality on a
personal Web site:

.. code-block:: python

    from django import forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField(required=False)

A form is composed of ``Field`` objects. In this case, our form has four
fields: ``subject``, ``message``, ``sender`` and ``cc_myself``. ``CharField``,
``EmailField`` and ``BooleanField`` are just three of the available field types;
a full list can be found in :doc:`/ref/forms/fields`.

If your form is going to be used to directly add or edit a Django model, you can
use a :doc:`ModelForm </topics/forms/modelforms>` to avoid duplicating your model
description.

Using a form in a view
----------------------

The standard pattern for processing a form in a view looks like this:

.. code-block:: python

   def contact(request):
       if request.method == 'POST': # If the form has been submitted...
           form = ContactForm(request.POST) # A form bound to the POST data
           if form.is_valid(): # All validation rules pass
               # Process the data in form.cleaned_data
               # ...
               return HttpResponseRedirect('/thanks/') # Redirect after POST
       else:
           form = ContactForm() # An unbound form

       return render_to_response('contact.html', {
           'myform': form,
       })


There are three code paths here:

    1. If the form has not been submitted, an unbound instance of ContactForm is
       created and passed to the template.
    2. If the form has been submitted, a bound instance of the form is created
       using ``request.POST``. If the submitted data is valid, it is processed
       and the user is re-directed to a "thanks" page.
    3. If the form has been submitted but is invalid, the bound form instance is
       passed on to the template.

The distinction between **bound** and **unbound** forms is important. An unbound
form does not have any data associated with it; when rendered to the user, it
will be empty or will contain default values. A bound form does have submitted
data, and hence can be used to tell if that data is valid. If an invalid bound
form is rendered it can include inline error messages telling the user where
they went wrong.

See :ref:`ref-forms-api-bound-unbound` for further information on the
differences between bound and unbound forms.

Handling file uploads with a form
---------------------------------

To see how to handle file uploads with your form see
:ref:`binding-uploaded-files` for more information.

Processing the data from a form
-------------------------------

Once ``is_valid()`` returns ``True``, you can process the form submission safe
in the knowledge that it conforms to the validation rules defined by your form.
While you could access ``request.POST`` directly at this point, it is better to
access ``form.cleaned_data``. This data has not only been validated but will
also be converted in to the relevant Python types for you. In the above example,
``cc_myself`` will be a boolean value. Likewise, fields such as ``IntegerField``
and ``FloatField`` convert values to a Python int and float respectively. Note
that read-only fields are not available in ``form.cleaned_data`` (and setting
a value in a custom ``clean()`` method won't have any effect) because these
fields are displayed as text rather than as input elements, and thus are not
posted back to the server.

Extending the above example, here's how the form data could be processed:

.. code-block:: python

    if form.is_valid():
        subject = form.cleaned_data['subject']
        message = form.cleaned_data['message']
        sender = form.cleaned_data['sender']
        cc_myself = form.cleaned_data['cc_myself']

        recipients = ['info@example.com']
        if cc_myself:
            recipients.append(sender)

        from django.core.mail import send_mail
        send_mail(subject, message, sender, recipients)
        return HttpResponseRedirect('/thanks/') # Redirect after POST

For more on sending email from Django, see :doc:`/topics/email`.

Further topics
==============

This covers the basics, but forms can do a whole lot more:

.. toctree::
   :maxdepth: 2

   rendering
   formsets
   modelforms
   media

.. seealso::

    :doc:`The Forms Reference </ref/forms/index>`
        Covers the full API reference, including form fields, form widgets,
        and form and field validation.
